-v0.1 2023.10.30 Sherlock init
-v0.2 2023.10.31 Sherlock ...
-v0.3 2023.11.06 Sherlock ...
-v0.4 2023.11.07 Sherlock ...
-v0.5 2023.11.08 Sherlock ...
-v0.6 2023.11.09 Sherlock 在目录上补全的2.2/2.3的所有章节。
-v0.7 2023.12.07 Sherlock 补充2.3.2的内容
-v0.8 2023.12.08 Sherlock 增加TTD/TLBI的内容，还是不明白的多。


简介：本文是ARM64 spec 2.2/2.3章节的学习笔记。ARM的spec不同的版本这两节的定义语言
      描述变化有点大，我们这里使用的是2023.4.12的版本，另外，这个版本的行文似乎
      比较乱，看的时候可以对比着上一个版本的看。

2.2
====
 
这一节定义的是ARM64中定义的原子行为，这个可以看作是软硬件对原子行为定义的约定。
比如，2.2.1就定义了哪些是single-copy atomicity的，我理解这些定义的atomicity，在
软件开来应该都是原子的，这部分的定义和硬件怎么实现是无关的。

2.2.1
------

定义哪些操作是single-copy atomicity。我们挑选几条看下，第一条"A read that is
generated by a load instruction that loads a single general-purpose register
and ..."，这条是说一个自然对齐的load指令一定是原子的。

2.2.1章节随后对所有的情况做了明确的定义，可以看到SIMD相关的定义占了大部分。

2.2.2
------

single-copy atomic访问的定义，就是定义single-copy atomic操作具有的性质: 1. 两个
single-copy atomic写，如果地址重叠，那么一定是一个整体上在另一个的前或后执行；
2. 两个single-copy atomic操作，一个读一个写，访问地址重叠，如果他们之间存在RAW关系，
写不会coherence-after读。(第二点原文应该这里有点笔误)

2.2.3
------

定义了multi-copy atomicity: 相同地址上的写是串行的，所有observer看到的写顺序是一样
的，所有observer是同步读到相同地址上的值的。

2.2.4
------

ARM定义Normal/device memory都不要求是multi-copy atomic。

2.2.5
------

多核之间，一个core执行的指令可能被另一个core修改，这一节的内容与此相关。

2.2.6
------

原子指令在实现上的一些约束。

2.3
====

这一节定义ARM的内存模型，为了方便说明，前面几节都是在介绍定义。总的来讲，定义包括
两大类，第一类是静态定义的order上的约束，比如，address dependency，当两个指令有
存在这样的关系的时候，两个指令的实际执行顺序是确定的，第二类是指令的可能行为，比如，
read from，在两个core之间，当一个core上的store指令和另一个core上的load指令访问相同
地址的时候，他们之间就可能存在read from关系，就是store改变了地址上的数据，然后load
从地址上读到改变的数据，但是这个read from关系只是表示结果，因为可能load在store前
运行，这样就不会有read form的关系。ARM spec里对这两类定义区分的并不是很清晰，当然
也可能是英语水平的原因。

2.3.1
------

这一节是基础名词的定义，这些基础名词的定义和后面使用的地方是对应的，这里给出了所有
情况下的定义，我们这里先根据基本的定义，把握下定义的主线。所以，我们这里先不关注
某些特性的所有定义，比如和memory tag相关的定义，后面如果需要，我们在针对某个特性
整体考虑。

observer: 定义系统里可以发起读写请求的部件，比如CPU核或者外设。

common shareability domain:

location: 物理或者虚拟地址上的一个byte。

program order: 程序中所展现的指令之间的先后关系。 

effects: 指令执行产生的影响，比如对寄存器有影响的叫register effect，对内存的影响
         叫memory effect，这里的effect的分类有点随心所欲，似乎是哪里需要了，就在
	 这里加个定义，比如还有什么branching effect, TLBI effect, fault effect...

reads-from-register: 描述的是相同寄存器之间的RAW关系。

reads-from memory: 描述的是相同地址之间的RAW关系。没有提是不是相同observer，所以
                   这个关系是可以存在不同observer上的。

coherence order: 描述多个observer对相同地址写操作的关系。注意这里说这个是一个
                 “total order”，序理论上全序是指集合中任意两个元素都是可比的。

local read successor: 在一个observer上，描述相同地址之间的RAW关系。

local write successor: 在一个observer上，描述相同地址之间的写操作在写操作或读操作
                       之后的关系。

coherence-before: 
在一个coherence order关系里，排在前面的写操作coherence-before后面的写操作。

store addr(W3)/load addr(R1)/store addr(W2)的关系里，如果R1 reads-from-memory W3,
W3 coherence-before W2, 那么R1 coherence-before W2。(什么鬼?)

对于store addr(W1) -> store addr(W2)和store addr(W1) -> load addr(R2)，两种情况中
后者均没有对前者有coherence-before的关系。这里的load/store操作相同地址，并且先后
是program order。

(Tag相关的先不看)

observed-by: 在不同observer上，如果W2 coherence-after RW1，就是说在相同地址上W2
	     的访问排到RW1的后面，我们说RW1 observed-by W2。(W2和RW1需要是explict
	     的memory effect，先忽略Tag相关操作)

overlapping accesses: 就是地址访问有重叠。

single-copy-atomic-class: 所有single-copy-atomic触发的memory effects组成的集合。

single-copy-atomic-order-before: ??

implicit translation table descriptor(TTD) memory effects:
硬件对页表内存做隐式内存访问产生的effect，具体上有page table walk和对access/dirty
bit的修改。

hardware update effect: 特指对access/dirty bit修改产生的effect。基于这个还定义了
hardware-update-predecessor/hardware-update-successor。

tag memory effects/checked memory effects: 这两个是和memory tag相关的effect。

barrier effects: spec上写的是DSB/DMB/ISB带来的effect，其他barrier指令怎么看？

context synchronization effects(CSE effect): ISB或异常进入退出带来的effect。

branch effects: 各种branch指令带来的改变PC的effect。

TLBI effects/completed TLBI effect: tlbi指令会产生TLBI effect，tlbi后面加一个DSB.FULL
指令会产生completed TLBI effect。基于此概念，还定义了TLBI-before/TLBI-after，比如，
TLBI-before的定义是，一个completed TLBI effect和一个TTB read之间的顺序。

fault effects, exception entry/return effects: 这块定义的比较混乱，定义关系之间
会重叠，比如异常进入退出的effect，在上面又叫CSE effect。反正按照字面意思可以看懂
就好。

TLB uncacheable effects: 把translation fault/access flag fault/address size fault
产生的effect归类为TLB uncacheable effect。基于这个概念还定义了TLB uncacheable-write-predecessor和
TLB uncacheable-write-successor。

low order bits/same low order bits/same location: 这组定义是为了定义最后的same
location，这里说的不清楚。

2.3.2
------

这一节定义的是单条指令内在dependency关系，像CSEL/CAS/SWAP这种读写effect都有的指令，
CAS Xs, Xt, [Xn]指令中，如果Xs和Xn地址上的数据相等，就把Xt的值写到Xn地址上。

注意，2.3.2的标题是“intrinsic dependency relations”，就是这一节定义的还是”关系“，
并没有定义指令之间要准守的先后循序。

CSEL Xd, Xn, Xm, cond 指令根据cond从PSTATE.NZCV的对应位或取信息，然后把Xn或Xm的
值传递给Xd。

SWP Xs, Xt, [Xn] 指令把Xn地址上的值load出来(data)，把Xs写入Xn的地址，并把之前load
出的data写到Xt里。

2.3.3
------

translation-intrinsically-before。协议里写比较模糊，加个例子比较好。

对于同一个指令中的两个effect，一个是implicit TTD read memory effect R1，后者是
显示内存读写effect或者是fault effect E2。如果R1和一个intrinsic branch effect B3
有数据依赖，B3和E2有控制依赖，那么E1和E2就存在这个关系。

直观上看，最明显的一个例子就是load/store触发page fault的流程。不清楚E2是显示内存
读写的时候，具体的场景是什么？

2.3.4
------

tag-check-intrinsically-before

2.3.5
------

各种dependency的定义，定义的是依赖的形式，至于基于这些依赖形式的指令先后顺序，这里
并没有定义。但是，可以看到这里定义的各种dependency关系，到后面会有对应的静态order
定义出来。

dependency through registers and memory:
一个PE上，寄存器或者地址上的RAW关系。一条指令中的data dependency关系。关系可以传递。

basic dependency:
两个effect是一样的(相同observed，相同作用结果)。上述的registers/memory dependency。

address dependency:
简单理解为，对于两个memory effect的指令，后一条指令用了前一条指令的输出作为地址。

data dependency:
简单理解为，对于两个memory effect的指令，后一条指令的数据用了前一条指令的输出。

control dependency:
只是定义了控制依赖的形式，有没有序要上要求，这里没有说啊。

所以，我们可以简单总结下，对于address/data/control dependency基本上描述的是两条
memory操作指令之间的依赖关系，这些依赖关系不是前后指令直接在地址上的依赖关系。
可以看到这里和RISCV中定义的address/data/control dependency基本上是一样的。

后面pick xxx dependency中，似乎后一条指令里还有intrinsic的依赖？

2.3.6
------

各种order relation的定义。

CSE-ordered-before: 如上面提到的，上下文同步时的order。控制依赖里如果前一个指令
有显示memory read, 后一个指令有CSE effect，就是这种order。结合后面看，这种情况下
也是保序的。

dependency-ordered-before:

这里在定义order了，单核上的各种基本序都是这条里面定义的。“A dependency creates
externally-visible order between ...”，dependency创建了order，可以认为，这里定义
的是第一类静态order的约束。

注意这里的order细化了上面的dependency，我们看control dependency相关的order，在这里
明确提出了在一个control dependency里，后面的一个是memory write。也就是这里对后一个
effect是memory read的control dependency关系是没有序上的定义的，配合后面创建先后
关系的定义，control dependency里，后面的memory read是不存在先后顺序的约束的，这个
和我们一般的认知也是相符的。
...

pick-ordered-before:

atomic-ordered-before:

说明的是load-exclusive/store-exclusive指令里包含的order语意。

DSB-ordered-before:

DSB的order定义。

barrier-ordered-before:

主要讲DMB的order，以及带acquire/release属性的院子指令的order。

TTD-read-ordered-before:

这里描述了两种满足情况的定义，描述都是用effect的，为了简化描述，我们这里都有指令
来说明。第一种情况：E1 -> TLBI(E3) -> DSB.FULL(E4) -> E2(spec上说E2在E3之后?)(E2
不能是隐式内存effect)，也就是说E1改了页表，后面要加TLBI/DSB才能和E2中的内存访问
保序，这里E1/E2是什么effect，spec里没有写出来。第二种情况：FEAT_ETS2(enhanced
translation synchronization)支持时，情况1中的E2可以是implicit TTD memory effect。

在如上的两种情况中，E3是TLBI effect，那么根据TLBI-after的定义，E1是一个TTD read。
大概场景如下：
```
  core0:           core1:

  TTD read(E1)
                   TLBI(E3)
		   DSB.FULL(E4) E2
```
spec上说E2 program after E3，那么E2可能在DSB之前也可能在DSB之后？具体对应软件上
的什么场景？

TLBI-ordered-before:

一共有三种情况，第一种就是如上的TTD-read-ordered-before。后两种也依赖TTD的这个关系，
搞懂TTD是关键 :(

TLBI-coherence-before:

晕...

locally-ordered-before:

这里基本上汇集了单核上的所有order的定义。

pick-locally-ordered-before:

hardware-required-ordered-before:

包含了locally-ordered-before，又汇集了如上的其他类型的order定义。可以看到这里面
包含的都是我们最上面说的第一类静态的order关系。

hazard-ordered-before:

应该是特殊定义的一种order？

2.3.7
------

External ordering constraint的定义，包含了单核上order的定义，以及我们上面说的第二
类关系的表述，终极的约束是这些全部定义放到一起不能出现矛盾，就是定义的order关系
链上不能有环。

external visibility requirement:

这里external visibility requirement的描述包括了hardware-required-ordered-before,
hardware-required-ordered-before包含了单核上order的定义。

所以，这一节定义的order上的约束可以分两个大类，一个是单核上的order约束，一个是多核
上order约束的传递关系，其中第一个可以认为是我们上面说的静态定义的order关系，第二个
是上面第二类关系的延续。我们一个一个看下这里的定义:

- E1 hardware-required-ordered-before E2

- E1 hazard-ordered-before E2

- E1 Observed-by E2 or effects belongs to same single-copy-atomicity class as E2

  (single-copy-atomicity class是什么意思?) 结合observed-by的语意，这里似乎是在说
  多核之间对同一地址数据的自然观察结果，也就是说所谓“E1 Observed-by E2”是一个结果。

- E1是implicit TTD effect, E2 reads-from E1

  这里只是说可能有这样的关系存在。

- E2是implicit TTD effect, E2 reads-from E1

- E2 TLB uncacheable successor of E1

- E2 hardware update successor of E1

- E1 coherence-before E2，E1或E2是hardware update effect

- E2 TLBI-coherence-after E1

- E1 TLBI-ordered-before E2

- E1 ordered-before E3，E3 ordered-before E2

external completion requirement。

external global completion requirement 都展开分析下...

之前的ARM spec里有“Internal visibility requirement”的定义，里面明确有这样的语句：
“..., then M1 will be seen to occur before M2 by that Observer”，像这样的语句才是
在明确定义指令的先后关系。(2023.4.12版本的spec没有这一章节)

2.3.8
------

completion and endpoint ordering。

2.3.10
-------

SVE相关的内存序定义。

2.3.11
-------

投机执行相关的约束。

2.3.12
-------

ARM里所有barrier指令在这一节定义。

2.3.13
-------

limited ordering regions。就是用户可以自定义一些物理内存区域出来，这些内存区域里的
指令和load acquire/store release的定义是用户可以重新定义的。
