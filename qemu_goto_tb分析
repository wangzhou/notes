qemu goto tb分析
================

-v0.1 2023.1.13 Sherlock init

简介：分析goto tb什么要在一个page内，使用的qemu代码的版本是v7.1.50。

 [qemu tcg跳转的处理](https://wangzhou.github.io/qemu-tcg跳转的处理/)中分析了qemu
 中模拟跳转的逻辑jj
```
      VA1 ---> +---------------+ 
               |               |
               |               |  map1
               |               | ----------+
               |               |           |
               |               |           |
      VA2 ---> +---------------+           |        +---------------+ <--- PA1
               |               |           |        |               |
               |               |  map2     +------> |               |
               |               | ------+            |               |
               |               |       |            |               |
               |               |  map3 |            |               |
               +---------------+ ----+ |            +---------------+ <--- PA2
                                     | |            |               |
                                     | +----------> |               |
                                     |              |               |
                                     |              |               |
                                     |              |               |
                                     |              +---------------+ <--- PA3
                                     |              |               |
                                     +------------> |               |
                                                    |               |
                                                    |               |
                                                    |               |
                                                    +---------------+
     tb1 key: pa1
     +-------+ <---------------------+   <------ htable
     |       |                       |
     |       |                       |
     +-------+                       |
         |                           |
         |                           |
         |                           |
         v tb2 key: pa2              |
     +-------+ <-------------+       |
     |       |               |       |
     |       |               |       |
     +-------+               |       |
                             |       |
                             |       |
     tb_jmp_cache key: va    |       |
     +--------------------------------------------------------------+
     |                      va2     va1                             |
     +--------------------------------------------------------------+
```
 qemu在翻译执行的时候，对于tb有两个cache，首先所有生成的tb都会放到htable这个哈希表，
 这个是我们这里说的第一个cache，这个哈希表的key是guest代码块的起始pa以及一些其它的
 flag，另外一个cache叫tb_jmp_cache，这个是很简单的用guest代码块的起始va做key。

 htable用pa以及flag做key，在翻译执行的时候首先会用va查tlb得到pa，如果tlb里没有缓存，
 那就触发page table walk或者取指令异常，终归是要把pa找到并填到tlb里。

 当程序运行时，一段代码的位置，从va看是不变的，但是代码的物理存储位置可能是变化的，
 比如上图中从map2到map3映射的改变。从htable的设计上看，当这种映射关系改变的时候，
 旧映射对应的tb就应该从htable里删掉。

 tb_jmp_cache用va做key是存在问题的，一个系统里可能有相同的va映射到不同的pa，比如，
 两个进程的va相同，映射的pa就可能不同。所以，要保证在tb_jmp_cache里，va只唯一映射
 一个pa，当va到pa的映射改变的时候，tb_jmp_cache里



 store_helper
   +--> notdirty_write(env_cpu(env), addr, size, full, retaddr);
     +-> tb_invalidate_phys_page_fast(pages, ram_addr, size, retaddr);
       +-> tb_invalidate_phys_page_range__locked
         +-> tb_phys_invalidate__locked(tb);
	   +-> do_tb_phys_invalidate(tb, true);
	     +-> qht_remove(&tb_ctx.htable, tb, h)



