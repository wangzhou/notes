-v0.1 2024.4.26 Sherlock init

简介：本文梳理Linux内核基于NMI的watchdog的基本逻辑。分析依赖的Linux内核版本是v6.8-rc5


基本逻辑
---------

代码分析
---------

内核初始化时会调用lockup_detector_init，这里是soft lockup和hard lockup的入口，

```
lockup_detector_init
      /* kernel/watchdog_perf.c */
  +-> watchdog_hardlockup_probe

        /* 先检测当前硬件平台上有没有支持NMI中断的PMU */
    +-> arch_perf_nmi_is_available

        /* 有NMI中断的PMU, 使用PMU的counter中断(配置成NMI)检测hard lockup */
    +-> hardlockup_detector_event_create
          /* 根据watchdog_thresh计算counter的采样间隔 */
      +-> wd_attr->sample_period = hw_nmi_get_sample_period(watchdog_thresh)
          /* 注册PMU event */
      +-> perf_event_create_kernel_counter(wd_attr, cpu, NULL, watchdog_overflow_callback, NULL)
          /* 更新watchdog_ev为如上得到perf_event*/
      +-> this_cpu_write(watchdog_ev, evt)

        /* 对于soft lockup打开的情况，在soft lockup后重新启动hard lockup */
    +-> lockup_detector_setup
      +-> if (watchdog_enabled && watchdog_thresh)
            softlockup_start_all()
          /* 目前是空函数？*/
      +-> watchdog_hardlockup_start()
          /* ？*/
      +-> __lockup_detector_cleanup()

watchdog_overflow_callback
  +-> watchdog_check_timestamp
  +-> watchdog_hardlockup_check
        /* 
	 * 通过检测hrtimer_interrupts变量是否更新来判断hard lockup，而hrtimer_interrupts
	 * 这个变量是在soft lockup的hrtimer处理函数中更新的。如果这个变量不变化，
	 * 表示一段时间都没有hrtimer中断，判断发生了hard lockup。
	 * 
	 * 可见关中断的时间如果太长就会触发hard lockup。
	 */
    +-> is_hardlockup(cpu)
```
