-v0.1 2025.6.14 Sherlock init

简介：本文分析KVM虚拟化场景下vCPU上下线的基本逻辑，重点分析vCPU上下线的时间点。


基本逻辑
---------

只分析禁止内核抢占的Linux系统。对于这样的系统，在内核态执行时，如果被中断后，中断
执行完后将继续原来的执行流程，在内核态执行，除非内核代码显示让出CPU，否则内核态
的执行流程将持续进行。对于这样的系统，线程调度只发生在：1. 内核态显示让出CPU，2.
内核态返回用户态的调度点。

所以，KVM中当vCPU通过ioctl run进入虚机运行时，vCPU线程被调度出去的时间也只有如上
两个点。具体而言就是：1. vCPU退出到KVM执行时，在KVM里主动让出CPU；2. vCPU一路退出
到qemu时，从host退出到用户态的调度点发生调度。

先分析vCPU在guest运行时会因为什么原因退出来：1. vCPU的相关指令触发了trap，trap
到KVM来模拟，KVM在模拟的时候就可能主线让出CPU，比如WFI的模拟，也可能退到qemu处理，
这样vCPU线程也可能被调度走。2. 处于guest状态的vCPU被host上的中断打断，这种情况下
vCPU先退出到KVM，然后换上host的中断异常向量，开中断后，这个中断会再次被taken，
处理完中断后，继续从KVM进入原来的vCPU。

KVM里让出CPU的点都有: 1. WFI/WFE的模拟逻辑，具体逻辑可以参考[这里](todo: ...)。

需要退出到qemu处理的情况定义到了include/uapi/linux/kvm.h的KVM_EXIT_XXX。

内核中的一段流程长时间占据CPU就会触发softlockup，那不是可以写一段不触发退出的
程序，在qemu-kvm上运行就会触发softlockup?

todo: 对于支持抢占的内核。

vCPU上线时间点
---------------


vCPU下线时间点
---------------


vCPU上下线API
--------------


vCPU线程调度点
---------------


vCPU关中断关抢占逻辑
---------------------


观测手段
---------


