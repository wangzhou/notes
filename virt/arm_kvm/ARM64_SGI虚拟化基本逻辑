-v0.1 2025.2.1 Sherlock init
-v0.2 2025.2.2 Sherlock ...

简介：本文整理ARM KVM中vSGI实现的基本逻辑。


基本逻辑
---------

物理SGI通过写ICC_SGI0R_EL1/ICC_SGI1R_EL1/ICC_ASGI1R_EL1触发。虚拟化下，vCPU写对
应的寄存器会触发trap到KVM。GICv3/v4.0需要通过list register向vCPU注入vSGI，GICv4.1
支持vCPU在线的时候通过GITS_SGI寄存器直接向vCPU注入vSGI。

如上的三个寄存器用来区分group和security，具体又和所在的EL级别有关系。ICC_SGI0R_EL1
表示触发一个group0的SGI，在各个特权级下，group0都是FIQ；ICC_SGI1R_EL1表示触发一个
group1的SGI，security类型和当前PE相同；ICC_ASGI1R_EL1也是触发group1的SGI，只是
security类型和当前PE不一样。

如上各个寄存器的标记，SGI的目标CPU，中断号以及是否做广播。
```
       55     48      40  39     32        27  24 23     16 15        0
+-----+---------+----+---+---------+------+------+---------+-----------+
|     |affinity3|    |IRM|affinity2|      |SGI ID|affinity1|target list|
+-----+---------+----+---+---------+------+------+---------+-----------+
```
使用affinity3/2/1以及target list标记系统里的CPU，这个和MPIDR_EL1寄存器标记CPU的
语意是一致的。IRM为1表示向所有CPU广播，IRM为0才用如上affinity/target list域段指定
目标CPU。

其中，如上寄存器的target list和MPIDR_EL1的affinity0有所不同，前者16个bit表示具体
affinity1下的16个CPU，所以GIC支持向一个affinity1下的多个CPU发SGI多播。而MPIDR_EL1
的affinity0用8bit的位宽表示一个数。这里的设计看起来是对不上的。

ICH_HCR_EL2.TC控制访问相关寄存器是否trap到EL2。

GICv3/v4.0 vSGI需要使用list register由KVM注入vCPU。todo: 展开逻辑？

GICv4.1时，KVM通过写GITS_SGIR寄存器直接注入vSGI，GITS_SGIR使用vPEID和vINTID表示
目标vCPU和SGI中断号。KVM需要把收到的affinity3/2/1+target list转换成vPEID，然后使
用GITS_SGIR发送vSGI。

ARM KVM下，vCPU中MPIDR_EL1由vcpu_id在KVM中转换计算得到对应的MPIDR_EL1的值，KVM保
存MPIDR_EL1和vPEID的映射关系。注意，vcpu_id在每个VM里，从0开始依次编号；MPIDR是
ARM下硬件标记CPU编号的方式；vPEID是GIC视角的vCPU编号，在host上这个是vCPU的唯一编
号。

todo: 直接使用GITS_SGIR还需要哪些前置的配置？KVM配置ITS的寄存器把信息传给硬件，
硬件需要知道vCPU当前在哪个物理CPU上，才能转发给对应的GICR；GICR需要知道vCPU当前
是否在线，在线直接注入，不在线就把信息记录下，触发doorbell中断，doorbell中断处理
里触发vCPU上线响应vSGI中断。所以，这里至少需要这两个对应的前置配置，第一个配置复
用VMAPP/VMOVP等配置，第二个配置使用VSGI命令？

todo: 通过list register注入中断?

KVM代码分析
------------

ICC_SGI1R_EL1 trap的逻辑。
```
kvm_handle_sys_reg
  ...
  +-> access_gic_sgi
        /*
         * 从affinity的语意转换到vPEID的语意。
         *
         */
    +-> vgic_v3_dispatch_sgi
      +-> vgic_v3_queue_sgi

        +-> vgic_queue_irq_unlock               <--- GICv3/v4.0的注入逻辑

        +-> irq_set_irqchip_state               <--- GICv4.1的vSGI直通逻辑 
          +-> chip->irq_set_irqchip_state
                /* GITS_SGIR触发vSGI的逻辑 */
            +-> its_sgi_set_irqchip_state
```

todo: irq-gic-v3-its.c里有多个irqchip：GICv4-vpe，GICv4.1-vpe，GICv4.1-sgi，ITS。
它们的语意如何理解？

GITS_SGIR触发vSGI的逻辑。
```
```

vSGI的基本逻辑。
```
```

todo: 如下这些数据结构的语意，以及是怎么组合到一起的。

irq_chip/irq_domain

irq/irq_data/irq_desc

vgic_irq
  +-> host_irq

SGI内核代码分析
----------------

todo











