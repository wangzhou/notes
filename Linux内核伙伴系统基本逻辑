-v0.1 2023.10.09 Sherlock init
-v0.2 2023.10.10 Sherlock

简介：文本分析Linux内核内存管理中伙伴系统的基本逻辑。


基本逻辑
---------

伙伴系统的目的就是为了缓解内存分配中的内存碎片。写过内存分配的人对此有直接的认识，
系统里有一大块内存，不同的用户不断请求和释放不同大小的内存，一个直观的管理办法是，
把这一大块内存按照相同的单位分成大小相等的块，根据请求内存的大小依次从这些块中分配
内存，当大小内存混合分配时，随着内存块的不断分配和释放，小块内存很容易分配的很分散，
导致大块内存分配困难。
```
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
| a | b | b | b | c | d | d | d |           | a |   |   |   | c |   |   |   |
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
| d | e | f | f | f | f | g | h |   ---->   |   | e |   |   |   |   | g |   |
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
| h | h | h | h | h | i | j | j |           |   |   |   |   |   | i |   |   |
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
```
如上即使大的内存块释放了，由于小内存块分散分布，我们无法跨越小内存块而分配出大的
内存块来。

伙伴系统的基本逻辑是，小块内存在一个内存块里分，大块内存在另一个内存块里分，这里
所谓的大小内存块可以有很多级。
```
       +---+---+---+---+---+---+---+---+
  L0   | a | b | c | d |   |   |   |   |
       +---+---+---+---+---+---+---+---+
  L1   | e | e | f | f | g | g |   |   |
       +---+---+---+---+---+---+---+---+
  L2   | h | h | h | h | i | i | i | i |
       +---+---+---+---+---+---+---+---+
```
如上，一个小块内存(可以叫一个page)的分配只在L0的内存块里分，只在L1分配连续两个page，
只在L2分配连续四个page。这样小的内存块天然就被局限在特定的内存区域里了，它们不会
出来捣乱。

但是，这里有个问题，比如L0内存分完了，L1/L2又有内存，如何把L1/L2的内存让出来给L0
用，L0用完后再换给L1/L2。
```
       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
  L0   | a |-->| b |-->| c |-->| d |-->| j |-->| k |-->| l |-->| m |
       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+

       +---+---+   +---+---+   +-------+   +---+---+
  L1   | e | e |-->| f | f |-->| g | g |-->|   |   |
       +---+---+   +---+---+   +---+---+   +---+---+   -------------\
                                                                     \
       +---+---+---+---+   +---+---+---+---+                          \
  L2   | h | h | h | h |-->| i | i | i | i |                           \      allocated
       +---+---+---+---+   +---+---+---+---+                            \       |
                                                                         v      v

       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+  +---+
  L0   | a |-->| b |-->| c |-->| d |-->| j |-->| k |-->| l |-->| m |-->|   |  |   |
       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+  +---+

       +---+---+   +---+---+   +-------+
  L1   | e | e |-->| f | f |-->| g | g |
       +---+---+   +---+---+   +---+---+

       +---+---+---+---+   +---+---+---+---+
  L2   | h | h | h | h |-->| i | i | i | i |
       +---+---+---+---+   +---+---+---+---+
```
如上，在各个内存区域里，使用链表管理各个内存块，当L0的内存不够用的时候，就从更高
一级的内存域里(如上是L1)把一个大内存块分开，一部分分给用户使用，一部分挂入L0的空闲
内存链表。当L0 allocated内存使用完，返回空闲链表时，如果它的“伙伴”也是空闲的，那么
就可以把他们合并成一个L1的大块，挂回L1的空闲链表，这样分配大内存块时，就可以使用。
注意，伙伴系统里的空闲链表上的是空闲的内存，如上图里为了表示方便，在内存块里写了
字母表示连续分配的内存。

如上可以把大块内存拆成小块用。小块内存如何聚合给大块内存用，大块内存使用的情况有
传统大页和透明大页(THP)，传统大页和伙伴系统没有关系，THP的大页一般是2MB页，也就是
伙伴系统里order是9的页(一个基础页是4KB)，当order为9的内存域里没有内存可分配时就要
通过内存迁移调整出2MB大页。(需要结合代码确定这个逻辑)

内存迁移的基本逻辑。在有虚拟内存的系统里，比如Linux系统，内核给用户呈现的内存语意
在虚拟地址上，也就是说用户针对一个虚拟地址读写数据就可以了，这给内核内部扩展了腾挪
空间，也就是说一个虚拟地址上的数据可能一会保存在一个物理内存上，一会保存在另一个
物理地址上。这里物理页面上数据迁移的动作就叫内存迁移。

内存迁移的一个目的就是提高访问性能，进程可能会在不同核上迁移，如果不同核跨越了NUMA
节点，内存访问的效率会降低，内核通过内存迁移把数据搬移到CPU所在NUMA的内存上，这样
相同NUMA内内存访问效率高。

内存迁移也可以缓解内存上的碎片，比如对于如上从L1拆借到L0的内存，如果L0里有其他页面
空余了，就可以把数据迁移到空余的页表，从而把从L1中拆借出来的页面拼成大一点的内存
块还给L1内存域。

代码分析
---------

实际上，如果你用/proc/buddyinfo查看系统一开始buddy系统的信息，会发现内存基本上都
挂在order上最大的空闲链表上，那么特性order的内存区域可能不像上面分析的那样是预先
分配好的，而是不断的从大order内存区域上拆下来的，那么在拆的过程中就要尽可能的把
小order内存块都安排在一起，这个算法还需要具体看下。
