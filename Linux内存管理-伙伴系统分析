-v0.1 2023.10.09 Sherlock init

简介：文本分析Linux内核内存管理中伙伴系统的基本逻辑。


伙伴系统，内存迁移，reclaim/swap


伙伴系统的目的就是为了缓解内存分配中的内存碎片。写过内存分配的人对此有直接的认识，
系统里有一大块内存，不同的用户不断请求和释放不同大小的内存，一个直观的管理办法是，
把这一大块内存按照相同的单位分成大小相等的块，根据请求内存的大小依次从这些块中分配
内存，当大小内存混合分配时，随着内存块的不断分配和释放，小块内存很容易分配的很分散，
导致大块内存分配困难。
```
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
| a | b | b | b | c | d | d | d |           | a |   |   |   | c |   |   |   |
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
| d | e | f | f | f | f | g | h |   ---->   |   | e |   |   |   |   | g |   |
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
| h | h | h | h | h | i | j | j |           |   |   |   |   |   | i |   |   |
+---+---+---+---+---+---+---+---+           +---+---+---+---+---+---+---+---+
```
如上即使大的内存块释放了，由于小内存块分散分布，我们无法跨越小内存块而分配出大的
内存块来。

伙伴系统的基本逻辑是，小块内存在一个内存块里分，大块内存在另一个内存块里分，这里
所谓的大小内存块可以有很多级。
```
       +---+---+---+---+---+---+---+---+
  L0   | a | b | c | d |   |   |   |   |
       +---+---+---+---+---+---+---+---+
  L1   | e | e | f | f | g | g |   |   |
       +---+---+---+---+---+---+---+---+
  L2   | h | h | h | h | i | i | i | i |
       +---+---+---+---+---+---+---+---+
```
如上，一个小块内存(可以叫一个page)的分配只在L0的内存块里分，只在L1分配连续两个page，
只在L2分配连续四个page。这样小的内存块天然就被局限在特定的内存区域里了，它们不会
出来捣乱。

但是，这里有个问题，比如L0内存分完了，L1/L2又有内存，如何把L1/L2的内存让出来给L0
用，L0用完后再换给L1/L2。
```
       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
  L0   | a |-->| b |-->| c |-->| d |-->| j |-->| k |-->| l |-->| m |
       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+

       +---+---+   +---+---+   +-------+   +---+---+
  L1   | e | e |-->| f | f |-->| g | g |-->|   |   |
       +---+---+   +---+---+   +---+---+   +---+---+   -------------\
                                                                     \
       +---+---+---+---+   +---+---+---+---+                          \
  L2   | h | h | h | h |-->| i | i | i | i |                           \      allocated
       +---+---+---+---+   +---+---+---+---+                            \       |
                                                                         v      v

       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+  +---+
  L0   | a |-->| b |-->| c |-->| d |-->| j |-->| k |-->| l |-->| m |-->|   |  |   |
       +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+  +---+

       +---+---+   +---+---+   +-------+
  L1   | e | e |-->| f | f |-->| g | g |
       +---+---+   +---+---+   +---+---+

       +---+---+---+---+   +---+---+---+---+
  L2   | h | h | h | h |-->| i | i | i | i |
       +---+---+---+---+   +---+---+---+---+
```
如上，在各个内存区域里，使用链表管理各个内存块，当L0的内存不够用的时候，就从更高
一级的内存域里(如上是L1)把一个大内存块分开，一部分分给用户使用，一部分挂入L0的空闲内存链表。
当L0 allocated内存使用完，返回空闲链表时，如果它的“伙伴”也是空闲的，那么





