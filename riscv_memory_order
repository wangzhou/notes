riscv内存模型分析
==================

-v0.1 2023.2.23 Sherlock init
-v0.2 2023.2.24 Sherlock 增加riscv内存序规则

简介：本文整理riscv的内存模型，基于riscv unprivileged ISA 20191213这个版本。其实
      对于使用弱内存序的构架，它们的内存模型都是比较相似的，无非是细节上有可能有
      一点不一样，本文也可以做为弱内存序相关的一个基础介绍。


基本逻辑
---------

 各个CPU构架的弱内存模型都会定义一些规则，这些规则约束各种内存序，在这些规则之外
 各种内存访问都是可以乱序的，所谓barrier指令只是其中的一些规则，这些规则用指令的
 方式显示约束了内存序，所以，只从barrier指令去看内存序，始终是只能看到其中的一部分，
 整体认识上还是模模糊糊。如果编程中会遇到可能的内存序问题，这些规则怎么说也的通读
 一遍，不然基本上就是一个“能跑就行”的程序。

 riscv协议在Chapter 14定义了这些规则(ARMv8/v9协议在2.3章定义了相关规则)，在附录里
 专门做了这些规则的解释(RVWMO Explanatory Material, Version 0.1)，在附录里还有内存
 序相关的形式化验证模型(Formal Memory Model Specifications, Version 0.1)。

riscv内存序规则
----------------
 
 riscv在Chapter 14定义Preserved Program Order，其中有13条规则(rule)，大部分是符合
 我们的直观的认识，但是也有一些和直观的认知是不同的。我们逐条看下这写规则:
```
• Overlapping-Address Orderings

  1. b is a store, and a and b access overlapping memory addresses  

  2. a and b are loads, x is a byte read by both a and b, there is no store to x
     between a and b in program order, and a and b return values for x written by
     different memory operations  

  3. a is generated by an AMO or SC instruction, b is a load, and b returns a value
     written by a  
```
 访存地址有重合的情况，第一条规则是说后面的store不能跑到前面的指令之前执行。

 第二条规则就比较绕了，直接翻译是，a和b是load操作，x是a和b读到的值，a和b之间没有对x
 这个值的修改(?)，a和b load的值会被不同的内存写操作改变，这个规则翻译出来还是比较
 费解？

 第三条规则是说，后面的load不能超过之前由AMO/SC触发的写操作，直观的理解也是这样。

```
• Explicit Synchronization 

  4. There is a FENCE instruction that orders a before b

  5. a has an acquire annotation

  6. b has a release annotation

  7. a and b both have RCsc annotations 

  8. a is paired with b 
```
 用显示的barrier指令指定内存序的情况，这些去看barrier的定义就好，需要注意的点有：

 acquire语意是说acquire后面的读写指令不能排到acquire之前(没有约束acquire之前读写
 指令的顺序)，逻辑示意如下。release的语意正好相反。
```
         +-------------+
         | load/store  |---------+
         +-------------+         |
                                 |
----- instruction with acquire --+--
  ^                              |
  |      +-------------+         |
  +------| load/store  |         v
         +-------------+          
```
 第七条规则中的RCsc指的是Release Consistency with sequentially-consistent synchronization
 operation。(引用了一篇经典的论文?)

 第八条规则说的a和b是一个pair，是说lr/sc指令组成的pair。

```
• Syntactic Dependencies 

  9. b has a syntactic address dependency on a

  10. b has a syntactic data dependency on a

  11. b is a store, and b has a syntactic control dependency on a 
```
 这几条规则说的是指令之间语意上的依赖，和最开始访存地址重合的依赖比较类似。需要
 注意的是规则11，控制依赖里面，后面的store的顺序是不能乱的，这里没有提load，也就
 是说load是可以乱的，todo详细分析：
```
 todo
```

```
• Pipeline Dependencies 

  12. b is a load, and there exists some store m between a and b in program order
      such that  m has an address or data dependency on a, and b returns a value
      written by m  

  13. b is a store, and there exists some instruction m between a and b in program
      order such that m has an address dependency on a  
```
 这两条规则是说，依赖之间是可以前后构成依赖链条的。

riscv barrier指令
------------------

 (fence/fence.i)

ARM内存序以及barrier指令
-------------------------

 (todo)

Linux内核内存序介绍
--------------------

 Linux内核有详细介绍内存序的文档：Documentation/memory-barriers.txt。
