riscv内存模型分析
==================

-v0.1 2023.2.23 Sherlock init
-v0.2 2023.2.24 Sherlock 增加riscv内存序规则

简介：本文整理riscv的内存模型，基于riscv unprivileged ISA 20191213这个版本。其实
      对于使用弱内存序的构架，它们的内存模型都是比较相似的，无非是细节上有可能有
      一点不一样，本文也可以做为弱内存序相关的一个基础介绍。


基本逻辑
---------

 各个CPU构架的弱内存模型都会定义一些规则，这些规则约束各种内存序，在这些规则之外
 各种内存访问都是可以乱序的，所谓barrier指令只是其中的一些规则，这些规则用指令的
 方式显示约束了内存序，所以，只从barrier指令去看内存序，始终是只能看到其中的一部分，
 整体认识上还是模模糊糊。如果编程中会遇到可能的内存序问题，这些规则怎么说也的通读
 一遍，不然基本上就是一个“能跑就行”的程序。

 riscv协议在Chapter 14定义了这些规则(ARMv8/v9协议在2.3章定义了相关规则)，在附录里
 专门做了这些规则的解释(RVWMO Explanatory Material, Version 0.1)，在附录里还有内存
 序相关的形式化验证模型(Formal Memory Model Specifications, Version 0.1)。

riscv内存序规则
----------------

 riscv在Chapter 14定义了它的弱内存序，定义的逻辑是这样的，"Memory Model Primitives"
 这一节是一些术语的定义，"Syntactic Dependencies"这一节定义的是两个指令关系的名称，
 这一节并没有定义内存序的规则，后面定义规则时依赖这一节里定义的指令关系，"Preserved Program Order"
 这一节定义的是riscv弱内存序的规则，这一节是这一章的主体，一共定义了13条规则(rule)，
 大部分是符合我们的直观的认识，但是也有一些和直观的认知是不同的。我们逐条看下这些规则:
```
• Overlapping-Address Orderings

  1. b is a store, and a and b access overlapping memory addresses  

  2. a and b are loads, x is a byte read by both a and b, there is no store to x
     between a and b in program order, and a and b return values for x written by
     different memory operations  

  3. a is generated by an AMO or SC instruction, b is a load, and b returns a value
     written by a  
```
 访存地址有重合的情况，第一条规则是说后面的store不能跑到前面的指令之前执行。

 第二条规则就比较绕了，直接翻译是，a和b是load操作，x是a和b读到的值，a和b之间没有对x
 这个值的修改(?)，a和b load的值会被不同的内存写操作改变，这个规则翻译出来还是比较
 费解？

 第三条规则是说，后面的load不能超过之前由AMO/SC触发的写操作，直观的理解也是这样。

```
• Explicit Synchronization 

  4. There is a FENCE instruction that orders a before b

  5. a has an acquire annotation

  6. b has a release annotation

  7. a and b both have RCsc annotations 

  8. a is paired with b 
```
 用显示的barrier指令指定内存序的情况，这些去看barrier的定义就好，需要注意的点有：

 acquire语意是说acquire后面的读写指令不能排到acquire之前(没有约束acquire之前读写
 指令的顺序)，逻辑示意如下。release的语意正好相反。
```
         +-------------+
         | load/store  |---------+
         +-------------+         |
                                 |
----- instruction with acquire --+--
  ^                              |
  |      +-------------+         |
  +------| load/store  |         v
         +-------------+          
```
 第七条规则中的RCsc指的是Release Consistency with sequentially-consistent synchronization
 operation。(引用了一篇经典的论文?)

 第八条规则说的a和b是一个pair，是说lr/sc指令组成的pair。

```
• Syntactic Dependencies 

  9. b has a syntactic address dependency on a

  10. b has a syntactic data dependency on a

  11. b is a store, and b has a syntactic control dependency on a 
```
 这几条规则说的是指令之间语意上的依赖，和最开始访存地址重合的依赖比较类似。

 需要注意的是规则11，这条规则提到了“控制依赖”，控制依赖的定义是，指令a和指令b，
 如果中间还有一条分支或者间接跳转指令(branch and indirect jump)m，如果a和m存在
 Syntactic Dependencies，那么b和a之间就存在一个控制依赖，而规则11是说，在a和b之间
 存在一个控制依赖时，如果b是个store指令，那么a和b是不能乱序的。

 riscv spec里在“Syntactic Dependencies”这一节定义各种依赖关系的定义，但是只是说
 当两条指令满足某种情况时，它们之间叫什么关系，并不是满足这种关系后就有序的约束，
 riscv spec随后在“Preserved Program Order”这一节借助"Syntactic Dependencies"的定义，
 描述内存序的约束，规则9和规则10，直接就说满足地址依赖和数据依赖的两条指令有内存
 序上的约束，而规则11是说在满足控制依赖关系时，只对后面是store的情况有序上的约束。

 规则11的代码示意如下，左边两个是不会乱序的情况，其中一个是汇编实现，一个是对应的
 C语言实现，最右边的是需要加读barrier的场景。
```
 load a0, a1(0)         a = read(p1);         a = read(p1); <--- 这个read后需要一个读barrier
 beqi a0, #1, lable     if (a == 1)           if (a == 1)
 store a2, a3(0)            write(p2, b);         c = read(p2);
```

```
• Pipeline Dependencies 

  12. b is a load, and there exists some store m between a and b in program order
      such that  m has an address or data dependency on a, and b returns a value
      written by m  

  13. b is a store, and there exists some instruction m between a and b in program
      order such that m has an address dependency on a  
```
 这两条规则是说，依赖之间是可以前后构成依赖链条的。

riscv barrier指令
------------------

 (fence/fence.i)

ARM内存序以及barrier指令
-------------------------

 (todo)

Linux内核内存序介绍
--------------------

 Linux内核有详细介绍内存序的文档：Documentation/memory-barriers.txt。
