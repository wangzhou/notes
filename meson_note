如何使用meson构建程序
=====================

-v0.1 2023.3.26 Sherlock init
-v0.2 2023.3.27 Sherlock 补充静态链接的配置
-v0.3 2023.3.29 Sherlock 补充glib的编译
-v0.4 2023.3.30 Sherlock 补充meson特性的基本介绍

简介：本文是使用meson构建程序的一个笔记，现在很多程序都是使用meson构建的，比如qemu、
      glib库等，了解下meson的基本逻辑在使用用meson构建的程序时逻辑会更加清晰。
      本文中的测试程序运行环境是ARM版本的ubuntu 20.04。

基本逻辑
---------

meson是用python写的一个程序构建工具，meson的官网在[这里](https://mesonbuild.com/index.html)，这里有meson的使用手册，
这个手册很好用。meson和make一样，需要写描述文件告诉meson要构建什么，这个描述文件
就是meson.build，meson根据meson.build中的定义生成具体的构建定义文件build.ninja，
ninja根据build.ninja完成具体构建。所以，不像make直接根据Makefile文件完成构建，meson
需要和ninja配合一起完成构建。

我们通过一个简单程序具体看下使用meson的方法，具体使用meson还是要学习下如上官网上
的手册。

首先在源码根目录下创建meson.build文件，文件内容：
```
project('learn_meson', 'c')
executable('hello', 'test.c')
```
这个文件定义了一个learn_meson的工程，并且定义了hello这个构建目标，以及test.c构建
使用的源文件。

在需要构建的源码根目录运行：
```
 meson setup builddir
```
这个是告诉meson在哪个目录下构建(这里是源码根目录下的builddir目录)，meson一定要在
一个和源码独立的目录里做构建，这样多次构建可以指定不同的构建目录和构建配置，相互
之间不受影响，比如对于同样的程序，构建一个riscv版本可以这样指定构建目录：
```
 meson setup --cross-file ./rv_cross_file rv_builddir
```
其中，rv_cross_file是指定一些构建要用的参数，当然你的系统里要有riscv的工具链。
rv_cross_file内容如下：
```
[host_machine]
system = 'linux'
cpu_family = 'riscv64'
cpu = 'riscv64'
endian = 'little'

[properties]
c_args = []
c_link_args = []

[binaries]
c = 'riscv64-linux-gnu-gcc'
cpp = 'riscv64-linux-gnu-g++'
ar = 'riscv64-linux-gnu-ar'
ld = 'riscv64-linux-gnu-ld'
objcopy = 'riscv64-linux-gnu-objcopy'
strip = 'riscv64-linux-gnu-strip'
```

运行如上命令后可以在源码根目录下发现对应的构建目录，里面有build.ninja文件。
```
sherlock@m1:~/tests/meson_test/build$ ls
build.ninja  compile_commands.json  hello.p  meson-info  meson-logs  meson-private
```

在源码根目录运行meson compile -C builddir，在builddir目录下即可以看到编译好的hello，
可以看到编译好的hello是动态链接的。进入builddir，运行meson configure可以看到default_library
一项是shared，meson configure显示构建的配置，默认为动态链接，可以使用如下命令修改
为静态链接：(注意，要在builddir下运行)
```
meson configure -Ddefault_library=static
```
再次meson compile -C builddir即可只构建出静态链接的程序。

一个例子：编译glib
--------------------

如下的方式可以本地编译glib:
```
 cd glib_source_dir
 meson setup build
 meson compile -C build
```

如果要静态编译可以：
```
 cd build
 meson configure -Ddefault_library=static
 cd ../
 meson compile -C build
```

glib库会编译出libglib/libgio/libgmodule，如果想只编译libglib，直观的办法是可以修改
meson.build文件，我们可以把相关的模块这样注释掉，这样就可以只编译libglib：
```
diff --git a/meson.build b/meson.build                                          
index 0cbc9689f..f5acd5f61 100644                                               
--- a/meson.build                                                               
+++ b/meson.build                                                               
@@ -82,9 +82,9 @@ darwin_versions = [current + 1, '@0@.@1@'.format(current + 1, interface_age)]
                                                                                
 configinc = include_directories('.')                                           
 glibinc = include_directories('glib')                                          
-gobjectinc = include_directories('gobject')                                    
-gmoduleinc = include_directories('gmodule')                                    
-gioinc = include_directories('gio')                                            
+# gobjectinc = include_directories('gobject')                                  
+# gmoduleinc = include_directories('gmodule')                                  
+# gioinc = include_directories('gio')                                          

@@ -2387,11 +2387,11 @@ pkg = import('pkgconfig')                               
 windows = import('windows')                                                    
 subdir('tools')                                                                
 subdir('glib')                                                                 
-subdir('gobject')                                                              
-subdir('gthread')                                                              
-subdir('gmodule')                                                              
-subdir('gio')                                                                  
-subdir('fuzzing')                                                              
+# subdir('gobject')                                                            
+# subdir('gthread')                                                            
+# subdir('gmodule')                                                            
+# subdir('gio')                                                                
+# subdir('fuzzing')                                                            
```

我们考虑交叉编译出riscv版本的libglib，使用如上交叉编译的方法会在setup过程中会自动
下载libffi，考虑到libglib并没有依赖libffi，我们直接把meson.build中的libffi依赖描述
这一行注释掉：
```
[...]
libm = cc.find_library('m', required : false)                                   
# libffi_dep = dependency('libffi', version : '>= 3.0.0')  <--- 注释掉这行
                                                                                
libz_dep = dependency('zlib')                                                   
[...]
```
这样最后可以只编译出riscv版本的libglib。

meson具体特性介绍
------------------

如上meson的官网有详细介绍meson的各种特性，我们这边持续的总结下，总结的思路是用类比
的方式看看make上的特性在meson上是怎么样，然后我们看meson特有的特性。

首先meson一定要像make一样，有描述构建target和构建依赖的语法，有自己的数据结构的
定义、函数方法的定义。上面用executable()定义编译的目标文件，如果target是构建库出来，
可以用library()，比如glib里定义libglib这个target是这样搞的：
```
libglib = library('glib-2.0',                                                   
  glib_dtrace_obj, glib_dtrace_hdr,                                             
  sources : [deprecated_sources, glib_sources],                                 
  version : library_version,                                                    
  soversion : soversion,                                                        
  darwin_versions : darwin_versions,                                            
  install : true,                                                               
  # intl.lib is not compatible with SAFESEH                                     
  link_args : [noseh_link_args, glib_link_flags, win32_ldflags],                
  include_directories : configinc,                                              
  link_with: [charset_lib, gnulib_lib],                                         
  dependencies : [                                                              
    gnulib_libm_dependency,                                                     
    libiconv,                                                                   
    libintl_deps,                                                               
    libm,                                                                       
    librt,                                                                      
    libsysprof_capture_dep,                                                     
    pcre2,                                                                      
    platform_deps,                                                              
    thread_dep,                                                                 
  ],                                                                            
  c_args : glib_c_args,                                                         
  objc_args : glib_c_args,                                                      
  gnu_symbol_visibility : 'hidden',                                             
)                                                                               
```
其中各个域段的语法要查meson library这个函数的具体定义，其中的dependencies域段表示
目标的依赖，而dependencies中的语段，比如，thread_dep，又是通过declare_dependency
生成的:
```
thread_dep = dependency('threads')                                            
```

todo: target

todo: Syntax/语法和python很像

todo: dependencies

todo: compiler property/检测系统信息

todo: subproject/wrap

todo: 生成代码

todo: option

todo: configuration

todo: 修改build.ninja

