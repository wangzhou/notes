-v0.1 2024.4.25 Sherlock init

简介：本文梳理Linux内核soft lockup检测机制的基本逻辑。分析依赖的Linux内核版本是
      v6.8-rc5


基本逻辑
---------

Linux内核调度各个不同的用户以及内核线程交替在CPU上运行，内核中的一段执行流长时间
的占用CPU时，会触发内核的soft lockup报错。

这里所谓的一段执行流是指用户线程的内核部分或者是内核线程。最常见的触发情况是，对
于不支持内核抢占的内核，内核中的一段执行流持续执行，没有主动让出CPU的情况。对于
非抢占内核，没有主动让出CPU，内核中的执行流总是持续执行。

注意，对于非抢占内核，中断打断一段内核执行流，中断执行后，将继续返回被打断的内核
执行流程，如果中断打断的是一段用户态执行流，中断执行完后，返回用户态被打算点前内
核会执行下调度，结果完全有可能是调度一个新的用户线程进来执行。

同样的道理，对于支持抢占的内核，在禁止抢占的内核执行流上，依然有上面的逻辑成立。

代码分析
---------
