Makefile再学习
==============

-v0.1 2021.9.12 Sherlock init

简介：本文是《跟我一起学Makefile》的一个学习笔记，N年前看过这个材料，现在再回头
      看下，温故而知新。然后在拿pciutils里手写的Makefile逐行对照着看下。本文也用于
      后面持续收集make相关的用法。


make和Makefile的基本逻辑
------------------------

 make以及Makefile完成的最基本的功能是，根据定义的依赖关系，决定是否执行相应的命令。
 相关的依赖描述可以写在默认名字的文件里，也可以用make -f决定使用哪个makefile文件。

 makefile文件只有一个最终目标target，是make解析makefile文件遇到的第一个target，
 但是，这并不是说只能编译出一个程序。可以像 all：target1 target2 target3 这样定义
 多个target，可以make all一次编译出所有target，也可以make target1，只编译出target1。

 make也支持只有target没有被依赖对象的定义，比如我们看到的clean目标，这是这样的目标
 叫做伪目标，要执行伪目标对应的命令需要显示的使用make，比如make clean。伪目标一般
 放到makefile文件的后面，并用.PHONY这样的伪目标定义下:
```
.PHONY: clean
	rm *.o
```
 伪目标可以支持和程序编译无关的一起操作，比如，程序的打包、安装、删除等等。

 可以想象要支持复杂的功能，make会定义自己的变量语法，流程控制的语法和函数。这些
 语法的定义都和shell的里的定义长的差不多。学习Makefile也就是对这些语法的学习。

变量
----

 变量在makefile里可以理解为一个宏，make在运行之前先做变量替换。一般变量直接定义，
 使用$()来引用，比如：
```
PREFIX=/usr/local
SBINDIR=$(PREFIX)/sbin
```
 
 变量的定义方式还可以用 := , ?= 和 +=。

 变量有其相关的作用域。一般定义的变量的作用域就是本makefile。使用export可以把所有
 当前makefile中的变量export到子makefile中，也可以export A只把A变量export到子makefile中。
 makefile里的变量，如果和环境变量一样，就会覆盖环境变量。还可以使用目标变量，把
 一个变量的作为范围只绑定到对应目标的命令上，目标变量的定义在下面pciutils makefile
 的分析中有提及。

 自动变量，$@, $<, $^, 其中$@表示target的集合，$<表示依赖中的第一个名字，$^表示
 依赖目标的集合。

流程控制
--------

 makefile可以把另一个makefile include进来。比如下面pciutils makefile中的
 -include lib/config.mk

 make可以进入另外的目录执行。比如pciutils makefile中的$(MAKE) -C lib all
 这个会进入lib目录，运行lib里的Makefile，进入退出lib目录的时候会有log提示。

 make中有分支语句。一般是，判断变量的值，然后根据判断结果决定是否执行命令，或者
 有相关的依赖条件。

 make中有支持循环的函数。其语法是：$(foreach <var>,<list>,<text>)，其中list是变量
 list，text是执行的表达式，var是每次取出的变量。比如：
```
names := a b c d
files := $(foreach n,$(names),$(n).o)
```
 $(files)的值是 a.o b.o c.o d.o

函数
----

 这里列出下面pciutils makefile里用的函数。

一些高级用法
------------

 make可以自动推导依赖关闭和要执行的命令，这叫make的隐含规则，其实就是对一些基本
 写法的省略表示。比如，对于.o的target，make自动推导依赖里有相同名字的.c存在，自动
 可以自动推导出基本的编译命令。

 隐含规则

 持续增加...

pciutils Makefile分析
---------------------

 我们把pciutils Makefile copy到这里，然后逐行分析下。pciutils的github地址在：
 https://github.com/pciutils/pciutils.git。我们直接用注释的方式写分析。
 用这个makefile做例子分析，有个缺点，是这个里面没有使用make的函数。
```
# Makefile for The PCI Utilities
# (c) 1998--2020 Martin Mares <mj@ucw.cz>

OPT=-O2

# 定义编译参数。make的隐含规则会自动的把这个编译参数加到编译里。
# 这里真是有点行业黑话的意思了 :)
CFLAGS=$(OPT) -Wall -W -Wno-parentheses -Wstrict-prototypes -Wmissing-prototypes

VERSION=3.7.0
DATE=2020-05-31

# Host OS and release (override if you are cross-compiling)
HOST=
RELEASE=
CROSS_COMPILE=

# Support for compressed pci.ids (yes/no, default: detect)
ZLIB=

# Support for resolving ID's by DNS (yes/no, default: detect)
DNS=

# Build libpci as a shared library (yes/no; or local for testing; requires GCC)
SHARED=no

# Use libkmod to resolve kernel modules on Linux (yes/no, default: detect)
LIBKMOD=

# Use libudev to resolve device names using hwdb on Linux (yes/no, default: detect)
HWDB=

# ABI version suffix in the name of the shared library
# (as we use proper symbol versioning, this seldom needs changing)
ABI_VERSION=.3

# Installation directories
PREFIX=/usr/local
SBINDIR=$(PREFIX)/sbin
SHAREDIR=$(PREFIX)/share
IDSDIR=$(SHAREDIR)

# 通过shell调用shell命令，这里判断特定的安装目录是否存在。
MANDIR:=$(shell if [ -d $(PREFIX)/share/man ] ; then echo $(PREFIX)/share/man ; else echo $(PREFIX)/man ; fi)
INCDIR=$(PREFIX)/include
LIBDIR=$(PREFIX)/lib
PKGCFDIR=$(LIBDIR)/pkgconfig

# Commands
INSTALL=install
DIRINSTALL=install -d
STRIP=-s
CC=$(CROSS_COMPILE)gcc
AR=$(CROSS_COMPILE)ar
RANLIB=$(CROSS_COMPILE)ranlib

# Base name of the library (overridden on NetBSD, which has its own libpci)
LIBNAME=libpci

# 使用include关键字把lib下的配置文件包含进来。可以看到config.mk只是定义了一些变量。
# 这里include之前的-表示忽略include过程中的报错。
-include lib/config.mk

PCIINC=lib/config.h lib/header.h lib/pci.h lib/types.h lib/sysdep.h
PCIINC_INS=lib/config.h lib/header.h lib/pci.h lib/types.h

# export这个makefile中的所有的变量到子make流程里，比如，下面使用$(MAKE) -C lib all
# 进入lib目录，调用lib目录里的Makefile文件编译其中定义的target，lib Makefile里就
# 可以看见本Makefile里定义的所有变量。
export

# 定义这个Makefile的总目标all，可以all又有一堆依赖，可以make all编译出所有，也可以
# make加一个依赖，只编译出其中的一个target。
all: lib/$(PCILIB) lspci setpci example lspci.8 setpci.8 pcilib.7 pci.ids.5 update-pciids update-pciids.8 $(PCI_IDS)

# 这里的定义是，如果头文件有变动，那么重新编译lib。似乎也有道理，头文件不动的话，
# 依然可以正常link，如果头文件都变动了，link一定会错。至于，头文件不同，lib的实现
# 变动了的情况，上面也只是单独编译lib。
#
# force是不管依赖条件，强制都跑下面命令的意思。这里的force和下面的force是一起的
# 逻辑，make的手册里相关的解释：gnu.org/software/make/manual/html_node/Force-Targets.html
#
# 简单讲就是force作为一个没有依赖，没有命令的伪目标，make认识force每次都update，
# 所以依赖force的target也没有都要执行下。
#
lib/$(PCILIB): $(PCIINC) force
	$(MAKE) -C lib all

force:

# 对于多目标的语法，一般拆开理解，比如下面的两个目标就可以拆开成：
# lib/config.h:
# 	cd lib && ./configure
# lib/config.mk:
# 	cd lib && ./configure
#
# 但是，拆开也比较费解?
#
lib/config.h lib/config.mk:
	cd lib && ./configure

# 如下的编译命令都是由make的隐含规则推导出来的。
lspci: lspci.o ls-vpd.o ls-caps.o ls-caps-vendor.o ls-ecaps.o ls-kernel.o ls-tree.o ls-map.o common.o lib/$(PCILIB)
setpci: setpci.o common.o lib/$(PCILIB)

LSPCIINC=lspci.h pciutils.h $(PCIINC)
lspci.o: lspci.c $(LSPCIINC)
ls-vpd.o: ls-vpd.c $(LSPCIINC)
ls-caps.o: ls-caps.c $(LSPCIINC)
ls-ecaps.o: ls-ecaps.c $(LSPCIINC)
ls-kernel.o: ls-kernel.c $(LSPCIINC)
ls-tree.o: ls-tree.c $(LSPCIINC)
ls-map.o: ls-map.c $(LSPCIINC)

setpci.o: setpci.c pciutils.h $(PCIINC)
common.o: common.c pciutils.h $(PCIINC)

# 这里的一个点是目标变量，他的语法是这样的：
#
# <target>: <variable-assignment>
# 语义是限定变量的作用范围，比如，如下，lspci的所有相关依赖命令中LDLIBS都用这里
# 赋予的值。CFLAGS的含义是一样的。
#
# LDLIBS, CFLAGS成了lspci，ls-kernel.o的相关命令的局部变量。
lspci: LDLIBS+=$(LIBKMOD_LIBS)
ls-kernel.o: CFLAGS+=$(LIBKMOD_CFLAGS)

# 如果update-pciids.sh有变化，要重新生成下update-pciids, sed命令没有看懂？
update-pciids: update-pciids.sh
	sed <$< >$@ "s@^DEST=.*@DEST=$(IDSDIR)/$(PCI_IDS)@;s@^PCI_COMPRESSED_IDS=.*@PCI_COMPRESSED_IDS=$(PCI_COMPRESSED_IDS)@"
	chmod +x $@

# The example of use of libpci
example: example.o lib/$(PCILIB)
example.o: example.c $(PCIINC)

# 定义模式规则。所有，xxx: xxx.o的编译命令都使用如下的隐含规则。
#
%: %.o
	$(CC) $(LDFLAGS) $(TARGET_ARCH) $^ $(LDLIBS) -o $@ --static -L../zlib

# 多target + 定义模式规则。可以展开成:
#
# %.8: %.man
# 	command
# %.7: %.man
# 	command
# %.5: %.man
# 	command
#
%.8 %.7 %.5: %.man
	M=`echo $(DATE) | sed 's/-01-/-January-/;s/-02-/-February-/;s/-03-/-March-/;s/-04-/-April-/;s/-05-/-May-/;s/-06-/-June-/;s/-07-/-July-/;s/-08-/-August-/;s/-09-/-September-/;s/-10-/-October-/;s/-11-/-November-/;s/-12-/-December-/;s/\(.*\)-\(.*\)-\(.*\)/\3 \2 \1/'` ; sed <$< >$@ "s/@TODAY@/$$M/;s/@VERSION@/pciutils-$(VERSION)/;s#@IDSDIR@#$(IDSDIR)#"

ctags:
	rm -f tags
	find . -name '*.[hc]' -exec ctags --append {} +

TAGS:
	rm -f TAGS
	find . -name '*.[hc]' -exec etags --append {} +

clean:
	rm -f `find . -name "*~" -o -name "*.[oa]" -o -name "\#*\#" -o -name TAGS -o -name core -o -name "*.orig"`
	rm -f update-pciids lspci setpci example lib/config.* *.[578] pci.ids.gz lib/*.pc lib/*.so lib/*.so.* tags
	rm -rf maint/dist

distclean: clean

# install伪目标依赖全部的目标。make install 会执行到下一个依赖之前。
install: all
# -c is ignored on Linux, but required on FreeBSD
	$(DIRINSTALL) -m 755 $(DESTDIR)$(SBINDIR) $(DESTDIR)$(IDSDIR) $(DESTDIR)$(MANDIR)/man8 $(DESTDIR)$(MANDIR)/man7 $(DESTDIR)/$(MANDIR)/man5
	$(INSTALL) -c -m 755 $(STRIP) lspci setpci $(DESTDIR)$(SBINDIR)
	$(INSTALL) -c -m 755 update-pciids $(DESTDIR)$(SBINDIR)
	$(INSTALL) -c -m 644 $(PCI_IDS) $(DESTDIR)$(IDSDIR)
	$(INSTALL) -c -m 644 lspci.8 setpci.8 update-pciids.8 $(DESTDIR)$(MANDIR)/man8
	$(INSTALL) -c -m 644 pcilib.7 $(DESTDIR)$(MANDIR)/man7
	$(INSTALL) -c -m 644 pci.ids.5 $(DESTDIR)$(MANDIR)/man5
ifeq ($(SHARED),yes)
ifeq ($(LIBEXT),dylib)
	ln -sf $(PCILIB) $(DESTDIR)$(LIBDIR)/$(LIBNAME)$(ABI_VERSION).$(LIBEXT)
else
	ln -sf $(PCILIB) $(DESTDIR)$(LIBDIR)/$(LIBNAME).$(LIBEXT)$(ABI_VERSION)
endif
endif

ifeq ($(SHARED),yes)
install: install-pcilib
endif

install-pcilib: lib/$(PCILIB)
	$(DIRINSTALL) -m 755 $(DESTDIR)$(LIBDIR)
	$(INSTALL) -c -m 644 lib/$(PCILIB) $(DESTDIR)$(LIBDIR)

install-lib: $(PCIINC_INS) lib/$(PCILIBPC) install-pcilib
	$(DIRINSTALL) -m 755 $(DESTDIR)$(INCDIR)/pci $(DESTDIR)$(PKGCFDIR)
	$(INSTALL) -c -m 644 $(PCIINC_INS) $(DESTDIR)$(INCDIR)/pci
	$(INSTALL) -c -m 644 lib/$(PCILIBPC) $(DESTDIR)$(PKGCFDIR)
ifeq ($(SHARED),yes)
ifeq ($(LIBEXT),dylib)
	ln -sf $(LIBNAME)$(ABI_VERSION).$(LIBEXT) $(DESTDIR)$(LIBDIR)/$(LIBNAME).$(LIBEXT)
else
	ln -sf $(LIBNAME).$(LIBEXT)$(ABI_VERSION) $(DESTDIR)$(LIBDIR)/$(LIBNAME).$(LIBEXT)
endif
endif

uninstall: all
	rm -f $(DESTDIR)$(SBINDIR)/lspci $(DESTDIR)$(SBINDIR)/setpci $(DESTDIR)$(SBINDIR)/update-pciids
	rm -f $(DESTDIR)$(IDSDIR)/$(PCI_IDS)
	rm -f $(DESTDIR)$(MANDIR)/man8/lspci.8 $(DESTDIR)$(MANDIR)/man8/setpci.8 $(DESTDIR)$(MANDIR)/man8/update-pciids.8
	rm -f $(DESTDIR)$(MANDIR)/man7/pcilib.7
ifeq ($(SHARED),yes)
	rm -f $(DESTDIR)$(LIBDIR)/$(PCILIB) $(DESTDIR)$(LIBDIR)/$(LIBNAME).so$(ABI_VERSION)
endif

#
pci.ids.gz: pci.ids
	gzip -9n <$< >$@

.PHONY: all clean distclean install install-lib uninstall force tags TAGS

```
