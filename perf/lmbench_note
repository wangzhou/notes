-v0.1 2025.8.2 Sherlock init

简介：随手记录一些lmbench的东西。

基本逻辑
---------
lmbench的官网在[这里](https://lmbench.sourceforge.net)，按照提示下载的是源码，
下载完后直接make编译出各个测试项的二进制，这个会保存在源码的bin目录下。用linux
发行版的也可以直接按转lmbench，比如，在ubuntu下直接：sudo apt-get install lmbench
就可以安装lmbench，这时lmbench被安装到/usr/lib/lmbench/。lmbench有详细的man文档，
可以man具体命令查看其对应用法。

lmbench的测试套项大概分三类带宽、时延和其它，带宽测试项的前缀是bw、时延是lat。

具体测试的时候，可以直接运行单个子项的测试用例，也可以整体运行，最后统一看整理
后的结果。后者，需要make results; make see。(todo: 没有运行起来)

测试子项
---------

下面依次看看每个测试项：

- bw_mem

测试内存带宽，其中又包含各种测试子项。如下是在M1上测试的一个数据，每个子项测试
10次，内存大小100MB。
```
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m wr
1048.58 19233.22
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m rd
1048.58 31315.73
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m rdwr
1048.58 23817.74
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m cp
1048.58 18237.37
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m fwr
1048.58 19501.86
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m frd
1048.58 23887.73
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m fcp
1048.58 17456.48
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m bzero
1048.58 64899.18
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./bw_mem -P 1 -W 0 -N 10 1000m bcopy
1048.58 23556.09
```

- lat_mem_rd

内存读时延测试。len的单位是MB，stride可配置，默认64B。这个测试会输出一组测试结果，
比如，如果lat_mem_rd 1 64，表示总的测试内存是1MB，stride为64B，其输出结果是：
```
sherlock@m1:~/repos/lmbench/lmbench-3.0-a9/bin$ ./lat_mem_rd 1 64
"stride=64
0.00049 0.941
0.00098 0.940
0.00195 0.940
0.00293 0.941
0.00391 0.939
0.00586 0.941
0.00781 0.940
0.01172 0.941
0.01562 0.941
0.02344 0.941
0.03125 0.940
0.04688 0.940
0.06250 0.941
0.09375 0.941
0.12500 0.941
0.18750 1.256
0.25000 1.511
0.37500 1.246
0.50000 1.240
0.75000 1.488
1.00000 1.648
```
每一行是一个测试结果，第一个值是测试内存的大小，单位是MB，第二个值是每次访问的平
均时间。这个测试内部不断的增加每次测试内存的大小，然后测试输出一个结果。每个测试
里会用当次总内存除以stride得到循环访问内存的次数，还不明白被访问内存的排布是怎么
样的。(todo)

看起来这个测试可以作为微架构测试，大概看出来L1/L2/L3 cache的大小。(todo)

- lat_syscall

测试getpid/open/read/write/stat/fstat的时间，比如，M1系统上getpid要大概需要如下
的时间：
```
sherlock@m1:/usr/lib/lmbench/bin$ taskset -c 0 ./lat_syscall -P 1 -W  0 -N 10 null /dev/n
ull
Simple syscall: 0.0767 microseconds
```

参考:
- https://www.cnblogs.com/ylxtiankong/p/18159724
