qemu tlb实现分析
=================

-v0.1 2023.2.16 Sherlock init
-v0.2 2023.2.17 Sherlock 继续写基本逻辑和代码分析

简介：本文分析qemu tcg里tlb实现的逻辑，分析基于的qemu版本是v7.1.50, 基于riscv构架。


TLB相关数据结构
----------------

 每个vCPU都有一个TLB相关的数据结构，riscv上这个结构在RISCVCPU neg域段的CPUTLB tlb结构里。

```
typedef struct CPUTLB {
    CPUTLBCommon c;
    CPUTLBDesc d[NB_MMU_MODES];
    CPUTLBDescFast f[NB_MMU_MODES];
} CPUTLB;
```
 如上是CPUTLB的结构，CPUTLBCommon存放TLB的公有信息，目前是dirty标记、锁和一些统计
 变量，CPUTLBDescFast和CPUTLBDesc存放的都是TLB的内容，两者组成一个两级TLB，其中
 CPUTLBDescFast是第一级，CPUTLBDesc是第二级，搜索的时候会先查第一级然后查第二级。

 NB_MMU_MODES表示TLB的种类，目前riscv上的定义是这样的：
```
  U mode 0b000                                                              
  S mode 0b001                                                              
  M mode 0b011                                                              
  U mode HLV/HLVX/HSV 0b100                                                 
  S mode HLV/HLVX/HSV 0b101                                                 
  M mode HLV/HLVX/HSV 0b111                                                 
```

 每个MMU mode下的CPUTLBDesc和CPUTLBDescFast都有若干个TLB entry组成的TLB表, 相关
 的TLB表的大小是可以动态调整的。其中一个TLB entry的定义是：
```
typedef struct CPUTLBEntry {
    union {
        struct {
            target_ulong addr_read;
            target_ulong addr_write;
            target_ulong addr_code;
            uintptr_t addend;
        };
        uint8_t dummy[1 << CPU_TLB_ENTRY_BITS];
    };
} CPUTLBEntry;
```
 TLB entry对读、写以及代码是分开做缓存的。

 qemu里的TLB模拟并不是对真实硬件的模拟，而是针对所有构架做的一个通用的TLB实现，
 它的目的是加速地址翻译。

基本逻辑
---------

 TLB的作用是加速地址访问时的地址翻译，地址访问一般分为显示地址访问和隐式地址访问，
 显示访问就是通过显示的load/store指令完成地址访问，隐式的访问是CPU在运行时不通过
 访存指令做的内存访问，比如访问页表以及取指令。不考虑虚拟化时，页表放在物理地址上，
 所以，我们这里先只考虑load/store以及取指令中涉及的TLB逻辑。

 TLB无效化是TLB相关的重要操作，一般也是软件和TLB打交道的唯一接口，有专门的TLB无效
 化指令触发相关的逻辑。当虚拟地址到物理地址的映射改变时，就需要做TLB的无效化操作，
 相关指令可以有不同的参数，定义TLB无效化的范围。

代码分析
---------


/*
 * Data elements that are shared between all MMU modes.
 */
typedef struct CPUTLBCommon {
    /* Serialize updates to f.table and d.vtable, and others as noted. */
    QemuSpin lock;
    /*
     * Within dirty, for each bit N, modifications have been made to
     * mmu_idx N since the last time that mmu_idx was flushed.
     * Protected by tlb_c.lock.
     */
    uint16_t dirty;
    /*
     * Statistics.  These are not lock protected, but are read and
     * written atomically.  This allows the monitor to print a snapshot
     * of the stats without interfering with the cpu.
     */
    size_t full_flush_count;
    size_t part_flush_count;
    size_t elide_flush_count;
} CPUTLBCommon;

typedef struct CPUTLBDesc {
    /*
     * Describe a region covering all of the large pages allocated
     * into the tlb.  When any page within this region is flushed,
     * we must flush the entire tlb.  The region is matched if
     * (addr & large_page_mask) == large_page_addr.
     */
    target_ulong large_page_addr;
    target_ulong large_page_mask;
    /* host time (in ns) at the beginning of the time window */
    int64_t window_begin_ns;
    /* maximum number of entries observed in the window */
    size_t window_max_entries;
    size_t n_used_entries;
    /* The next index to use in the tlb victim table.  */
    size_t vindex;
    /* The tlb victim table, in two parts.  */
    CPUTLBEntry vtable[CPU_VTLB_SIZE];
    CPUTLBEntryFull vfulltlb[CPU_VTLB_SIZE];
    CPUTLBEntryFull *fulltlb;
} CPUTLBDesc;

typedef struct CPUTLBDescFast {
    /* Contains (n_entries - 1) << CPU_TLB_ENTRY_BITS */
    uintptr_t mask;
    /* The array of tlb entries itself. */
    CPUTLBEntry *table;
} CPUTLBDescFast QEMU_ALIGNED(2 * sizeof(void *));


tlb里的dirty是在创建tlb的时候配置进去的，tlb_set_page, 各个架构里调用
