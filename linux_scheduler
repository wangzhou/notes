Linux内核调度的基本逻辑
------------------------

-v0.1 2022.9.15 Sherlock init

简介：本文分析Linux内核调度的基本逻辑，分析使用的内核版本是5.19-rc8，使用的qemu
      模型是v7.0.0, 硬件构架基于riscv。


调度要解决的问题
-----------------

 多个线程使用时分复用的方式分享一个CPU core，怎么时分复用；在多核系统下，如何把
 各个线程合理的分配到各个核上，这些都是调度要解决的问题。

 不同的线程有不同的属性，有的是CPU密集的，有的是IO密集的，有的优先级比较高，调度器
 需要尽可能的满足这些需求。

 调度的单位有时不只是线程，比如，一个台机器上，还可以限制不同用户对CPU资源的使用
 情况，这个也需要调度器参与。

 总体上，调度就是根据各种需求，动态的决定CPU资源给谁使用。

调度基本逻辑
-------------

 内核里并没有一个固定的点执行全部调度行为，各个执行调度的点散落在内核的各个部分。
 调度的逻辑根据系统运行状态进行调度，这些运行状态大概包括：线程的优先级，线程的
 运行时间，CPU的负载等等。调度的逻辑抽象出几个调度类: fair_sched_class, rt_sched_class,
 dl_sched_class, idle_sched_class等，每个线程和特定的调度类关联，调度类定义的是
 具体的调度行为，比如，fair_sched_class(完全公平调度器类)得到的调度行为表现为使用
 这种调度的各个线程尽可能公平的使用CPU，而rt_sched_class(实时调度器类)强调的是使用
 这种调度器的各个线程不能长时间得不到调度，在规定的时间内，总的都执行下各个线程。

 调度器是为每个CPU挑选运行的线程，所以，在实现上，会为每个CPU维护一个调度相关的数据
 结构，这个结构里保存各个调度类相关的运行队列。

 CFS

 RT

代码实现分析
-------------


