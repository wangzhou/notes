-v0.1 2022.10.24 Sherlock init
-v0.2 2022.11.8  Sherlock continue

简介：本文分析riscv内存管理相关的指令，主要包括，内存序、TLB无效化以及cache无效化
      的相关指令。分析使用的内核版本是v6.0，qemu版本是7.1.50。


涉及的指令
----------
```
+-------------+-------------------+----------------------------+
|内存序：     | fence fence.i     |                            |
|	      | sfence.w.inval    |                            |
|             | sfence.inval.ir   |                            |
+-------------+-------------------+----------------------------+
|TLB无效化:   | sfence.vma        |    hfence.vvma hfence.gvma |
|             | sinval.vma        |                            |
+-------------+-------------------+----------------------------+
|cache无效化: | CMO扩展                                        |
+-------------+-------------------+----------------------------+
```
如上是rv里和内存管理相关的指令一个总结，虚拟化相关的放在了右边，cache无效化相关
的指令在rv上在一个独立的扩展里介绍的：https://github.com/riscv/riscv-CMOs

下面我们逐条指令分析下：(先不考虑虚拟化相关的指令)

内存序指令
----------

 - fence

   fence指令是RV的基本指令，定义在非特权ISA spec里。fence是数据访问的fence指令，
   通过参数可以控制fence指令制造出的约束。

 - fence.i

   RV协议在Zifencei扩展里定义fence.i, Zifencei在RV的非特权级ISA定义里。fence.i只是
   对单核起作用，它保证是本核指令改动和CPU取指令之间的顺序，比如，软件改动了指令
   序列，希望CPU可以fetch改动后的指令，就必须加一个fence.i指令，这个指令确保CPU
   之前对指令的改动已经生效。

   协议里对多核的描述是，改动指令的核需要先执行一个fence指令，然后在其他核上均执行
   一个fence.i指令，才能保证如上的语意。软件上可以看到的一个场景是进程迁移的场景，
   一个进程开始在核A上，修改了自己的将要执行的指令，然后迁移到核B上去继续执行修改
   后的指令，在迁移之前就需要执行fence指令，再在核B上执行fence.i。
 
   todo：需要分析对应的代码。

TLB无效化指令
-------------

 - sfence.vma

   sfence.vma是定义在RV特权级ISA里的指令，我们可以简单把它理解成带barrier的tlb无效
   化指令。

   所谓barrier，保证的是修改页表和CPU做page walk的顺序，这两个操作之间需要加sfence.vma，
   保证CPU后面做page walk的时候拿到的时候修改之后的页表。

   这个指令支队单核起作用，多核之间做页表和tlb的同步在RV上需要多条指令完成，显然
   目前的做法，效率是不高的。多核之间做页表和tlb同步的常见是很常见的，比如，多线程
   共用一个虚拟地址空间，而且多个线程跑到多个核上，那么一个核修改了页表，其他核上
   的tlb就需要做无效化。RV协议上给出的方案是，修改页表的核修改页表后执行fence，这个
   保证叫所有核看见页表的修改，然后发IPI给其它核，其他核上的IPI处理函数执行sfence.vma，
   做完后通知修改页表的核。RV协议上叫这个过程是：模拟TLB shutdown。


 - sinval.vma

   sinval.vma和sfence.vmao功能类似，区别在于sinval.vma不带barrier。

   todo: 内核里的使用方式。

cache无效化指令
---------------

   todo
