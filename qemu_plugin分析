qemu plugin分析
================

-v0.1 2023.4.30 Sherlock init
-v0.2 2023.5.09 Sherlock 加入plugin机制分析

简介：本文分析qemu plugin的实现机制，了解qemu plugin的机制后，我们可以很容易的写
      一个plugin出来，用qemu plugin的方式为qemu增加新的功能。分析基于的qemu版本是
      v7.1.50。


qemu plugin基本概念以及使用
----------------------------

qemu tcg支持用插件的方式为qemu新增功能，qemu源码里作为示例自带了几个插件，我们先
编译使用下qemu自带的cache插件。

一般情况下qemu tcg是不模拟cache的，qemu自带了一个简单模拟cache的插件。我们在配置
qemu的时候要带上--enable-plugins，编译完qemu后，进入qemu/build/contrib/plugins/,
在这个目录下运行make，之后可以看见qemu的自带的plugin都编译出了，其中就有cache的
plugin: libcache.so。

按如下运行命令，可以带着cache plugin运行qemu，-d plugin输出plugin里的打印信息，
-D指定打印信息输出的文件：
```
qemu-system-riscv64 -m 256m -nographic -machine virt \
-kernel ~/repos/linux/arch/riscv/boot/Image \
-append "console=ttyS0 root=/dev/ram rdinit=/init" \
-initrd ~/repos/buildroot/output/images/rootfs.cpio.gz \
-plugin ~/repos/qemu/build/contrib/plugins/libcache.so \
-d plugin -D ~/qemu_cache_plugin_log
```
如上运行qemu后，linux内核启动从1s到了30s，可见qemu带plugin运行的速度是很慢的。

qemu plugin机制分析
--------------------

qemu要实现plugin就必然向外，也就是向plugin提供一组API接口，plugin使用这组API向qemu
注册以及获取qemu模拟的guest的信息。qemu内部为了支持plugin机制也会增加plugin的核心
实现代码。

首先我们从qemu user mode入手看下qemu是如何解析命令行里输入的plugin so的。
```
main
  +-> handle_arg_plugin(const char *arg)
    +-> qemu_plugin_opt_parse(const char *optarg, QemuPluginList *head)
```
可以看见qemu user mode会把解析到的每个plugin的信息放到qemu_plugin_desc，再把所有
的qemu_plugin_desc保存到一个叫plugins的全局链表里。

main函数里随后会使用qemu_plugin_load_list加载plugin so:
```
qemu_plugin_load_list()
  +-> plugin_load()
    +-> ctx->handle = g_module_open(desc->path, G_MODULE_BIND_LOCAL);
    +-> g_module_symbol(ctx->handle, "qemu_plugin_install", &sym));
        install = (qemu_plugin_install_func_t) sym;                                 
    +-> g_hash_table_lookup(plugin.id_ht, &ctx->id);
    +-> QTAILQ_INSERT_TAIL(&plugin.ctxs, ctx, entry);
    +-> install(ctx->id, info, desc->argc, desc->argv);                        
```
qemu内部对一个plugin的信息保存在qemu_plugin_ctx里，qemu全局的plugin信息保存到
struct qemu_plugin_state plugin里，注意上面的qemu_plugin_desc保存的只是plugin对应
的文件路径、参数等信息。struct qemu_plugin_state plugin里会用链表和哈希表分别记录
所有plugin。

qemu针对每个plugin，打开对应的动态库，执行动态库里名为qemu_plugin_install的函数。
每个plugin必须实现这个注册接口。

我们以libcache看看plugin怎么实现qemu_plugin_install。
```
/* qemu/contrib/plugins/cache.c */
qemu_plugin_install(qemu_plugin_id_t id, const qemu_info_t *info, int argc, char **argv)
  [...]
  +-> qemu_plugin_register_vcpu_tb_trans_cb(id, vcpu_tb_trans);                   
    +-> plugin_register_cb(id, QEMU_PLUGIN_EV_VCPU_TB_TRANS, cb);                   
  +-> qemu_plugin_register_atexit_cb(id, plugin_exit, NULL);                      
```
这个函数做了一些自己plugin的初始化后，调用了qemu plugin API注册了vcpu_tb_trans和
plugin_exit两个函数。所谓注册，就是把这两个函数保存到了plugin对应qemu_plugin_ctx
(后面简称ctx)的qemu_plugin_cb(后面简称cb)里，注意ctx里的cb是个数组，不同的数组项
描述不同的event，比如如上的QEMU_PLUGIN_EV_VCPU_TB_TRANS就是一个event，qemu在翻译
执行主流程里会调用这些注册的回调函数。

我们可以先观察下如上vcpu_tb_trans的行为，去掉其中业务相关的逻辑，其主逻辑如下：
```
vcpu_tb_trans()
  +-> n_insns = qemu_plugin_tb_n_insns(tb);                                       
  +-> for (i = 0; i < n_insns; i++) {                                             
      struct qemu_plugin_insn *insn = qemu_plugin_tb_get_insn(tb, i);         
      effective_addr = (uint64_t) qemu_plugin_insn_vaddr(insn);
      [...]
      qemu_plugin_register_vcpu_mem_cb(insn, vcpu_mem_access, QEMU_PLUGIN_CB_NO_REGS, rw, data);
      qemu_plugin_register_vcpu_insn_exec_cb(insn, vcpu_insn_exec, QEMU_PLUGIN_CB_NO_REGS, data);
  +-> }                                                                           
```
这个函数对于一个tb，调用qemu plugin的API得到guest指令数目、每个指令相关信息，并
针对每条guest指令使用qemu plugin API注册相关的回调函数，比如这里对每条guest指令
注册了vcpu_mem_access和vcpu_insn_exec两个函数。不同注册函数注册的回调函数在qemu
翻译执行主循环的不同位置被触发，plugin需要根据API的语意使用API注册回调函数。

我们进一步分析qemu内部是怎么实现回调函数的注册和触发的。
```
void qemu_plugin_register_vcpu_mem_cb(struct qemu_plugin_insn *insn,            
                                      qemu_plugin_vcpu_mem_cb_t cb,             
                                      enum qemu_plugin_cb_flags flags,          
                                      enum qemu_plugin_mem_rw rw,               
                                      void *udata)                              
{                                                                               
    plugin_register_vcpu_mem_cb(&insn->cbs[PLUGIN_CB_MEM][PLUGIN_CB_REGULAR],   
                                    cb, flags, rw, udata);                      
}                                                                               
```
从qemu_plugin_insn的内部结构可以看出来，针对一个guest指令，plugin可以注册两大类
回调函数：PLUGIN_CB_MEM和PLUGIN_CB_INSN，每一类里又分: PLUGIN_CB_REGULAR和PLUGIN_CB_INLINE。
被注册的函数以及相关的参数统统保存在insn的对应cb里(qemu_plugin_dyn_cb)。这里只是
保存了相关注册函数信息，被注册的函数还没有和qemu主流程关联在一起，和qemu主流程关
联的过程还是在qemu主流程里实现。

整个qemu翻译的主流程中被插入了plugin的桩函数以及桩函数的替换逻辑:
```
/* qemu/accel/tcg/translator.c */
translator_loop
  +-> plugin_enabled = plugin_gen_tb_start()
  +-> while (true) {
          if (plugin_enabled) {                                                   
              plugin_gen_insn_start(cpu, db);                                     
                +-> plugin_gen_empty_callback(PLUGIN_GEN_FROM_INSN)
                  +-> gen_wrapped(from, PLUGIN_GEN_ENABLE_MEM_HELPER, gen_empty_mem_helper)
                    +-> gen_plugin_cb_start(from, type, 0);                                         
                    +-> func();                                                                     
                    +-> tcg_gen_plugin_cb_end();                                                    
                  +-> gen_wrapped(from, PLUGIN_GEN_CB_UDATA, gen_empty_udata_cb);             
                  +-> gen_wrapped(from, PLUGIN_GEN_CB_INLINE, gen_empty_inline_cb);           
          }                                                                       

          ops->translate_insn(db, cpu);                                       

          if (plugin_enabled) {                                                   
              plugin_gen_insn_end();                                              
          }                                                                       
      }

  +-> if (plugin_enabled) {                                                       
          plugin_gen_tb_end(cpu);                                                 
      }                                                                           
```
plugin_gen_tb_start/plugin_gen_insn_start/plugin_gen_insn_end用来插入桩函数，
plugin_gen_tb_end主要用来做桩函数的替换。

我们顺序看一个plugin_gen_insn_start的处理。可以看见，这里插入了一些中间码，大概的
情况是：
```
plugin_cb_start PLUGIN_GEN_FROM_INSN, PLUGIN_GEN_ENABLE_MEM_HELPER
st_i64 0 cpu_env, offset of plugin_mem_cbs
plugin_cb_end

plugin_cb_start PLUGIN_GEN_FROM_TB, PLUGIN_GEN_CB_UDATA
ld_i32 cpu_index cpu_env, offset of cpu_index
call plugin_vcpu_udata_cb cpu_index, udata
plugin_cb_end

plugin_cb_start PLUGIN_GEN_FROM_TB, PLUGIN_GEN_CB_INLINE
ld_i64 val, ptr, 0
addi_i64 val, val, 0xdeadface
st_i64 val, val, 0
plugin_cb_end
```
如上的plugin_vcpu_udata_cb是一个空的桩函数。

```
plugin_gen_tb_end
  +-> qemu_plugin_tb_trans_cb(cpu, ptb);                                          
                                                                           
  +-> plugin_gen_inject(ptb);                                                     
```
qemu_plugin_tb_trans_cb扫描qemu全局的plugin，针对每个plugin，调用之前注册的
QEMU_PLUGIN_EV_VCPU_TB_TRANS event对应的回调函数。具体到上面的cache plugin就是
其中的vcpu_tb_trans函数。

我们就用cache的vcpu_tb_trans继续分析，这个函数里最主要的针对tb里的每个guest指令
调用qemu plugin API注册回调函数，其实这里的注册就是把回调函数保存到guest指令insn
结构体里，我们具体看其中一个：
```
qemu_plugin_register_vcpu_mem_cb(insn, vcpu_mem_access, QEMU_PLUGIN_CB_NO_REGS, rw, data);
  +-> plugin_register_vcpu_mem_cb(&insn->cbs[PLUGIN_CB_MEM][PLUGIN_CB_REGULAR], cb, flags, rw, udata);
```

plugin_gen_inject用注册的回调函数替换掉如上call中间码里的函数地址，并对输入参数做
必要的调整：
```
plugin_gen_inject(ptb)

  QTAILQ_FOREACH(op, &tcg_ctx->ops, link)
    switch (op->opc)
    [...]
    case INDEX_op_plugin_cb_start:                                          

      enum plugin_gen_from from = op->args[0];                            
      enum plugin_gen_cb type = op->args[1];                              
                                                                          
      switch (from)
      [...]
      case PLUGIN_GEN_FROM_INSN:                                          
        switch (type)
        case PLUGIN_GEN_CB_UDATA:                                       
          plugin_gen_insn_udata(plugin_tb, op, insn_idx);             
          break;                                                      
        case PLUGIN_GEN_CB_INLINE:                                      
          plugin_gen_insn_inline(plugin_tb, op, insn_idx);            
          break;                                                      
        case PLUGIN_GEN_ENABLE_MEM_HELPER:                              
          plugin_gen_enable_mem_helper(plugin_tb, op, insn_idx);      
          break;                                                      
```
如上代码识别plugin_tb_start开头的一段中间码，然后做匹配位置的函数替换以及参数生成
...
 
 todo: 分析细节

写一个自己的qemu plugin
------------------------

 todo: ...

